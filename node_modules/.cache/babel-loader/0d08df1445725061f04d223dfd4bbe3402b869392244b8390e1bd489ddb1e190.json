{"ast":null,"code":"// ~~strike through~~\n//\n'use strict';\n\nvar isWhiteSpace = require('../common/utils').isWhiteSpace;\nvar isPunctChar = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\n// parse sequence of markers,\n// \"start\" should point at a valid marker\nfunction scanDelims(state, start) {\n  var pos = start,\n    lastChar,\n    nextChar,\n    count,\n    isLastWhiteSpace,\n    isLastPunctChar,\n    isNextWhiteSpace,\n    isNextPunctChar,\n    can_open = true,\n    can_close = true,\n    max = state.posMax,\n    marker = state.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : 0x20;\n  while (pos < max && state.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n  if (pos >= max) {\n    can_open = false;\n  }\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? state.src.charCodeAt(pos) : 0x20;\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n  if (isNextWhiteSpace) {\n    can_open = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      can_open = false;\n    }\n  }\n  if (isLastWhiteSpace) {\n    can_close = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      can_close = false;\n    }\n  }\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\nmodule.exports = function strikethrough(state, silent) {\n  var startCount,\n    count,\n    tagCount,\n    found,\n    stack,\n    res,\n    token,\n    max = state.posMax,\n    start = state.pos,\n    marker = state.src.charCodeAt(start);\n  if (marker !== 0x7E /* ~ */) {\n    return false;\n  }\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n  if (!res.can_open) {\n    state.pos += startCount;\n    // Earlier we checked !silent, but this implementation does not need it\n    state.pending += state.src.slice(start, state.pos);\n    return true;\n  }\n  stack = Math.floor(startCount / 2);\n  if (stack <= 0) {\n    return false;\n  }\n  state.pos = start + startCount;\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n      tagCount = Math.floor(count / 2);\n      if (res.can_close) {\n        if (tagCount >= stack) {\n          state.pos += count - 2;\n          found = true;\n          break;\n        }\n        stack -= tagCount;\n        state.pos += count;\n        continue;\n      }\n      if (res.can_open) {\n        stack += tagCount;\n      }\n      state.pos += count;\n      continue;\n    }\n    state.md.inline.skipToken(state);\n  }\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  // Earlier we checked !silent, but this implementation does not need it\n  token = state.push('s_open', 's', 1);\n  token.markup = '~~';\n  state.md.inline.tokenize(state);\n  token = state.push('s_close', 's', -1);\n  token.markup = '~~';\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n};","map":{"version":3,"names":["isWhiteSpace","require","isPunctChar","isMdAsciiPunct","scanDelims","state","start","pos","lastChar","nextChar","count","isLastWhiteSpace","isLastPunctChar","isNextWhiteSpace","isNextPunctChar","can_open","can_close","max","posMax","marker","src","charCodeAt","String","fromCharCode","delims","module","exports","strikethrough","silent","startCount","tagCount","found","stack","res","token","pending","slice","Math","floor","md","inline","skipToken","push","markup","tokenize"],"sources":["E:/Projects/ASPHENIX/Pokedex-AI-v1/node_modules/markdown-it/lib/rules_inline/strikethrough.js"],"sourcesContent":["// ~~strike through~~\n//\n'use strict';\n\n\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\n\n// parse sequence of markers,\n// \"start\" should point at a valid marker\nfunction scanDelims(state, start) {\n  var pos = start, lastChar, nextChar, count,\n      isLastWhiteSpace, isLastPunctChar,\n      isNextWhiteSpace, isNextPunctChar,\n      can_open = true,\n      can_close = true,\n      max = state.posMax,\n      marker = state.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }\n\n  if (pos >= max) {\n    can_open = false;\n  }\n\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? state.src.charCodeAt(pos) : 0x20;\n\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    can_open = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      can_open = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    can_close = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      can_close = false;\n    }\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\n\n\nmodule.exports = function strikethrough(state, silent) {\n  var startCount,\n      count,\n      tagCount,\n      found,\n      stack,\n      res,\n      token,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker !== 0x7E/* ~ */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n  if (!res.can_open) {\n    state.pos += startCount;\n    // Earlier we checked !silent, but this implementation does not need it\n    state.pending += state.src.slice(start, state.pos);\n    return true;\n  }\n\n  stack = Math.floor(startCount / 2);\n  if (stack <= 0) { return false; }\n  state.pos = start + startCount;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n      tagCount = Math.floor(count / 2);\n      if (res.can_close) {\n        if (tagCount >= stack) {\n          state.pos += count - 2;\n          found = true;\n          break;\n        }\n        stack -= tagCount;\n        state.pos += count;\n        continue;\n      }\n\n      if (res.can_open) { stack += tagCount; }\n      state.pos += count;\n      continue;\n    }\n\n    state.md.inline.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  // Earlier we checked !silent, but this implementation does not need it\n  token        = state.push('s_open', 's', 1);\n  token.markup = '~~';\n\n  state.md.inline.tokenize(state);\n\n  token        = state.push('s_close', 's', -1);\n  token.markup = '~~';\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}