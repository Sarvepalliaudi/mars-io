{"ast":null,"code":"// Parser state class\n\n'use strict';\n\nvar Token = require('../token');\nfunction StateBlock(src, md, env, tokens) {\n  var ch, s, start, pos, len, indent, indent_found;\n  this.src = src;\n\n  // link to parser instance\n  this.md = md;\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n  this.bMarks = []; // line begin offsets for fast jumps\n  this.eMarks = []; // line end offsets for fast jumps\n  this.tShift = []; // indent for each line\n\n  // block parser variables\n  this.blkIndent = 0; // required block content indent\n  // (for example, if we are in list)\n  this.line = 0; // line index in src\n  this.lineMax = 0; // lines count\n  this.tight = false; // loose/tight mode for lists\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent = 0;\n  indent_found = false;\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n    if (!indent_found) {\n      if (ch === 0x20 /* space */) {\n        indent++;\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) {\n        pos++;\n      }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      indent_found = false;\n      indent = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  var token = new Token(type, tag, nesting);\n  token.block = true;\n  if (nesting < 0) {\n    this.level--;\n  }\n  token.level = this.level;\n  if (nesting > 0) {\n    this.level++;\n  }\n  this.tokens.push(token);\n  return token;\n};\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== 0x20 /* space */) {\n      break;\n    }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) {\n      break;\n    }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) {\n    return pos;\n  }\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) {\n      return pos + 1;\n    }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i,\n    first,\n    last,\n    queue,\n    shift,\n    line = begin;\n  if (begin >= end) {\n    return '';\n  }\n\n  // Opt: don't use push queue for single line;\n  if (line + 1 === end) {\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n    last = this.eMarks[end - 1] + (keepLastLF ? 1 : 0);\n    return this.src.slice(first, last);\n  }\n  queue = new Array(end - begin);\n  for (i = 0; line < end; line++, i++) {\n    shift = this.tShift[line];\n    if (shift > indent) {\n      shift = indent;\n    }\n    if (shift < 0) {\n      shift = 0;\n    }\n    first = this.bMarks[line] + shift;\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n    queue[i] = this.src.slice(first, last);\n  }\n  return queue.join('');\n};\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token;\nmodule.exports = StateBlock;","map":{"version":3,"names":["Token","require","StateBlock","src","md","env","tokens","ch","s","start","pos","len","indent","indent_found","bMarks","eMarks","tShift","blkIndent","line","lineMax","tight","parentType","ddIndent","level","result","length","charCodeAt","push","prototype","type","tag","nesting","token","block","isEmpty","skipEmptyLines","from","max","skipSpaces","skipChars","code","skipCharsBack","min","getLines","begin","end","keepLastLF","i","first","last","queue","shift","Math","slice","Array","join","module","exports"],"sources":["E:/Projects/ASPHENIX/Pokedex-AI-v1/node_modules/markdown-it/lib/rules_block/state_block.js"],"sourcesContent":["// Parser state class\n\n'use strict';\n\nvar Token = require('../token');\n\n\nfunction StateBlock(src, md, env, tokens) {\n  var ch, s, start, pos, len, indent, indent_found;\n\n  this.src = src;\n\n  // link to parser instance\n  this.md     = md;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // indent for each line\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent\n                       // (for example, if we are in list)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent = 0;\n  indent_found = false;\n\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (ch === 0x20/* space */) {\n        indent++;\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n\n      indent_found = false;\n      indent = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  var token = new Token(type, tag, nesting);\n  token.block = true;\n\n  if (nesting < 0) { this.level--; }\n  token.level = this.level;\n  if (nesting > 0) { this.level++; }\n\n  this.tokens.push(token);\n  return token;\n};\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, first, last, queue, shift,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  // Opt: don't use push queue for single line;\n  if (line + 1 === end) {\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n    last = this.eMarks[end - 1] + (keepLastLF ? 1 : 0);\n    return this.src.slice(first, last);\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    shift = this.tShift[line];\n    if (shift > indent) { shift = indent; }\n    if (shift < 0) { shift = 0; }\n\n    first = this.bMarks[line] + shift;\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    queue[i] = this.src.slice(first, last);\n  }\n\n  return queue.join('');\n};\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token;\n\n\nmodule.exports = StateBlock;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}