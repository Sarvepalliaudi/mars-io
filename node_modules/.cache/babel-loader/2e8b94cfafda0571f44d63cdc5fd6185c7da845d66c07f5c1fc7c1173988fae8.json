{"ast":null,"code":"/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n'use strict';\n\nvar assign = require('./common/utils').assign;\nvar unescapeAll = require('./common/utils').unescapeAll;\nvar escapeHtml = require('./common/utils').escapeHtml;\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar default_rules = {};\ndefault_rules.code_inline = function (tokens, idx /*, options, env */) {\n  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';\n};\ndefault_rules.code_block = function (tokens, idx /*, options, env */) {\n  return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\\n';\n};\ndefault_rules.fence = function (tokens, idx, options, env, self) {\n  var token = tokens[idx],\n    info = token.info ? unescapeAll(token.info).trim() : '',\n    langName = '',\n    highlighted;\n  if (info) {\n    langName = info.split(/\\s+/g)[0];\n    token.attrPush(['class', options.langPrefix + langName]);\n  }\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n  return '<pre><code' + self.renderAttrs(token) + '>' + highlighted + '</code></pre>\\n';\n};\ndefault_rules.image = function (tokens, idx, options, env, self) {\n  var token = tokens[idx];\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] = self.renderInlineAsText(token.children, options, env);\n  return self.renderToken(tokens, idx, options);\n};\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? options.xhtmlOut ? '<br />\\n' : '<br>\\n' : '\\n';\n};\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer() {\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independed static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules);\n}\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\n  var i, l, result;\n  if (!token.attrs) {\n    return '';\n  }\n  result = '';\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n  }\n  return result;\n};\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n  var nextToken,\n    result = '',\n    needLf = false,\n    token = tokens[idx];\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return '';\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n';\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag;\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token);\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /';\n  }\n\n  // Check if we need to add a newline after this tag\n  if (token.block) {\n    needLf = true;\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        nextToken = tokens[idx + 1];\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false;\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false;\n        }\n      }\n    }\n  }\n  result += needLf ? '>\\n' : '>';\n  return result;\n};\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var type,\n    result = '',\n    rules = this.rules;\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options);\n    }\n  }\n  return result;\n};\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  var result = '',\n    rules = this.rules;\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    if (tokens[i].type === 'text') {\n      result += rules.text(tokens, i, options, env, this);\n    } else if (tokens[i].type === 'image') {\n      result += this.renderInlineAsText(tokens[i].children, options, env);\n    }\n  }\n  return result;\n};\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  var i,\n    len,\n    type,\n    result = '',\n    rules = this.rules;\n  for (i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[tokens[i].type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options, env);\n    }\n  }\n  return result;\n};\nmodule.exports = Renderer;","map":{"version":3,"names":["assign","require","unescapeAll","escapeHtml","default_rules","code_inline","tokens","idx","content","code_block","fence","options","env","self","token","info","trim","langName","highlighted","split","attrPush","langPrefix","highlight","renderAttrs","image","attrs","attrIndex","renderInlineAsText","children","renderToken","hardbreak","xhtmlOut","softbreak","breaks","text","html_block","html_inline","Renderer","rules","prototype","i","l","result","length","nextToken","needLf","hidden","block","nesting","tag","type","renderInline","len","render","module","exports"],"sources":["E:/Projects/ASPHENIX/Pokedex-AI-v1/node_modules/markdown-it/lib/renderer.js"],"sourcesContent":["/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n'use strict';\n\n\nvar assign          = require('./common/utils').assign;\nvar unescapeAll     = require('./common/utils').unescapeAll;\nvar escapeHtml      = require('./common/utils').escapeHtml;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar default_rules = {};\n\n\ndefault_rules.code_inline = function (tokens, idx /*, options, env */) {\n  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';\n};\n\n\ndefault_rules.code_block = function (tokens, idx /*, options, env */) {\n  return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\\n';\n};\n\n\ndefault_rules.fence = function (tokens, idx, options, env, self) {\n  var token = tokens[idx],\n      info = token.info ? unescapeAll(token.info).trim() : '',\n      langName = '',\n      highlighted;\n\n  if (info) {\n    langName = info.split(/\\s+/g)[0];\n    token.attrPush([ 'class', options.langPrefix + langName ]);\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  return  '<pre><code' + self.renderAttrs(token) + '>'\n        + highlighted\n        + '</code></pre>\\n';\n};\n\n\ndefault_rules.image = function (tokens, idx, options, env, self) {\n  var token = tokens[idx];\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] =\n    self.renderInlineAsText(token.children, options, env);\n\n  return self.renderToken(tokens, idx, options);\n};\n\n\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n';\n};\n\n\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\n\n\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer() {\n\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independed static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules);\n}\n\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\n  var i, l, result;\n\n  if (!token.attrs) { return ''; }\n\n  result = '';\n\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n  var nextToken,\n      result = '',\n      needLf = false,\n      token = tokens[idx];\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return '';\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n';\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag;\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token);\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /';\n  }\n\n  // Check if we need to add a newline after this tag\n  if (token.block) {\n    needLf = true;\n\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        nextToken = tokens[idx + 1];\n\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false;\n\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false;\n        }\n      }\n    }\n  }\n\n  result += needLf ? '>\\n' : '>';\n\n  return result;\n};\n\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var type,\n      result = '',\n      rules = this.rules;\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options);\n    }\n  }\n\n  return result;\n};\n\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  var result = '',\n      rules = this.rules;\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    if (tokens[i].type === 'text') {\n      result += rules.text(tokens, i, options, env, this);\n    } else if (tokens[i].type === 'image') {\n      result += this.renderInlineAsText(tokens[i].children, options, env);\n    }\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  var i, len, type,\n      result = '',\n      rules = this.rules;\n\n  for (i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[tokens[i].type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options, env);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = Renderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}