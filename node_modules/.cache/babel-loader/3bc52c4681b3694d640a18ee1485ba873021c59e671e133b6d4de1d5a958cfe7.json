{"ast":null,"code":"// Process *this* and _that_\n//\n'use strict';\n\nvar isWhiteSpace = require('../common/utils').isWhiteSpace;\nvar isPunctChar = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\n// parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\nfunction scanDelims(state, start) {\n  var pos = start,\n    lastChar,\n    nextChar,\n    count,\n    can_open,\n    can_close,\n    isLastWhiteSpace,\n    isLastPunctChar,\n    isNextWhiteSpace,\n    isNextPunctChar,\n    left_flanking = true,\n    right_flanking = true,\n    max = state.posMax,\n    marker = state.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : 0x20;\n  while (pos < max && state.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? state.src.charCodeAt(pos) : 0x20;\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n  if (marker === 0x5F /* _ */) {\n    // \"_\" inside a word can neither open nor close an emphasis\n    can_open = left_flanking && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking || isNextPunctChar);\n  } else {\n    can_open = left_flanking;\n    can_close = right_flanking;\n  }\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\nmodule.exports = function emphasis(state, silent) {\n  var startCount,\n    count,\n    found,\n    oldCount,\n    newCount,\n    stack,\n    res,\n    token,\n    max = state.posMax,\n    start = state.pos,\n    marker = state.src.charCodeAt(start);\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {\n    return false;\n  }\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n  if (!res.can_open) {\n    state.pos += startCount;\n    // Earlier we checked !silent, but this implementation does not need it\n    state.pending += state.src.slice(start, state.pos);\n    return true;\n  }\n  state.pos = start + startCount;\n  stack = [startCount];\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          }\n\n          // assert(newCount > oldCount)\n          newCount -= oldCount;\n          if (stack.length === 0) {\n            break;\n          }\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n        state.pos += count;\n        continue;\n      }\n      if (res.can_open) {\n        stack.push(count);\n      }\n      state.pos += count;\n      continue;\n    }\n    state.md.inline.skipToken(state);\n  }\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n\n  // Earlier we checked !silent, but this implementation does not need it\n\n  // we have `startCount` starting and ending markers,\n  // now trying to serialize them into tokens\n  for (count = startCount; count > 1; count -= 2) {\n    token = state.push('strong_open', 'strong', 1);\n    token.markup = String.fromCharCode(marker) + String.fromCharCode(marker);\n  }\n  if (count % 2) {\n    token = state.push('em_open', 'em', 1);\n    token.markup = String.fromCharCode(marker);\n  }\n  state.md.inline.tokenize(state);\n  if (count % 2) {\n    token = state.push('em_close', 'em', -1);\n    token.markup = String.fromCharCode(marker);\n  }\n  for (count = startCount; count > 1; count -= 2) {\n    token = state.push('strong_close', 'strong', -1);\n    token.markup = String.fromCharCode(marker) + String.fromCharCode(marker);\n  }\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n};","map":{"version":3,"names":["isWhiteSpace","require","isPunctChar","isMdAsciiPunct","scanDelims","state","start","pos","lastChar","nextChar","count","can_open","can_close","isLastWhiteSpace","isLastPunctChar","isNextWhiteSpace","isNextPunctChar","left_flanking","right_flanking","max","posMax","marker","src","charCodeAt","String","fromCharCode","delims","module","exports","emphasis","silent","startCount","found","oldCount","newCount","stack","res","token","pending","slice","pop","push","length","md","inline","skipToken","markup","tokenize"],"sources":["E:/Projects/ASPHENIX/Pokedex-AI-v1/node_modules/markdown-it/lib/rules_inline/emphasis.js"],"sourcesContent":["// Process *this* and _that_\n//\n'use strict';\n\n\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\n\n// parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\nfunction scanDelims(state, start) {\n  var pos = start, lastChar, nextChar, count, can_open, can_close,\n      isLastWhiteSpace, isLastPunctChar,\n      isNextWhiteSpace, isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = state.posMax,\n      marker = state.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }\n\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? state.src.charCodeAt(pos) : 0x20;\n\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (marker === 0x5F /* _ */) {\n    // \"_\" inside a word can neither open nor close an emphasis\n    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking  || isNextPunctChar);\n  } else {\n    can_open  = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\n\nmodule.exports = function emphasis(state, silent) {\n  var startCount,\n      count,\n      found,\n      oldCount,\n      newCount,\n      stack,\n      res,\n      token,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n  if (!res.can_open) {\n    state.pos += startCount;\n    // Earlier we checked !silent, but this implementation does not need it\n    state.pending += state.src.slice(start, state.pos);\n    return true;\n  }\n\n  state.pos = start + startCount;\n  stack = [ startCount ];\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          }\n\n          // assert(newCount > oldCount)\n          newCount -= oldCount;\n\n          if (stack.length === 0) { break; }\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n        state.pos += count;\n        continue;\n      }\n\n      if (res.can_open) { stack.push(count); }\n      state.pos += count;\n      continue;\n    }\n\n    state.md.inline.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n\n  // Earlier we checked !silent, but this implementation does not need it\n\n  // we have `startCount` starting and ending markers,\n  // now trying to serialize them into tokens\n  for (count = startCount; count > 1; count -= 2) {\n    token        = state.push('strong_open', 'strong', 1);\n    token.markup = String.fromCharCode(marker) + String.fromCharCode(marker);\n  }\n  if (count % 2) {\n    token        = state.push('em_open', 'em', 1);\n    token.markup = String.fromCharCode(marker);\n  }\n\n  state.md.inline.tokenize(state);\n\n  if (count % 2) {\n    token        = state.push('em_close', 'em', -1);\n    token.markup = String.fromCharCode(marker);\n  }\n  for (count = startCount; count > 1; count -= 2) {\n    token        = state.push('strong_close', 'strong', -1);\n    token.markup = String.fromCharCode(marker) + String.fromCharCode(marker);\n  }\n\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}